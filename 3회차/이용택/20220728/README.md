# 🎞 후기
- 문제에 dict type으로 접근했을 때의 **강력함**을 몸소 느낄 수 있었다!
- 자료형의 내부 구조를 보았을 때 각 요소별로 접근해야하는 list와 달리 hash 값으로 관리되고 있다보니 모든 연산에서 리스트보다 더 우위에 있었다. 이를 통해 시간초과나서 실패한 문제 풀이를 성공적으로 마칠 수 있었다!
- 점점 시간 복잡도에 대한 이해와 반영이 요구되고 있다, 막연하게 for를 줄이고 메소드의 사용을 남발하지말자의 생각보다 이 자료형의 이 구조는 시간 복잡도가 높다 낮다를 판단할 수 있도록 메소드를 접할 때 마다, 시간 복잡도를 익혀둬야겠다.

## 💎 가장 강렬했던 문제
- 어려워서 고생했다기보다는 명심하면 좋겠었던 오늘의 문제들, 그 중 [백준 23825 - SASA모형](./BOJ_23825.py)
- 무조건 반복문, 조건문으로 해결하려하기 보다 모든 수단과 방법을 고려한 최적의 알고리즘을 만들어가자!
```python
# 풀이 1 : 연산 및 적은 양의 데이터에 대한 min() 사용 => 시간 복잡도 압도적으로 낮음, O(1)
n, m = map(int, input().split())
print(min(n // 2, m // 2))


# 풀이 2 : 처음 풀었던 방식으로 단순 수학적 논리를 반영한 while x if 의 환장의 콜라보레이션
# 시간복잡도 O(N^2)으로 풀이 1에 비하면 신생아 걸음마 속도랄까?
n, m = map(int, input().split())

cnt = 0 

while n >= 2 and m >= 2:
    
    if n - 2 >= 0 and m - 2 >= 0:
        cnt += 1
    
    n -= 2
    m -= 2

print(cnt)
```